# This Source Code Form is subject to the terms of the Mozilla Public
# License, v. 2.0. If a copy of the MPL was not distributed with this
# file, You can obtain one at https://mozilla.org/MPL/2.0/.

aldica.core.enabled=true
aldica.core.name=repositoryGrid
aldica.core.login=repository
aldica.core.password=repositoryGrid-dev
aldica.core.local.id=
aldica.core.local.host=
aldica.core.public.host=
aldica.core.public.time.port=
aldica.core.local.time.port=47120
aldica.core.local.time.portRange=0
aldica.core.initialMembers=

aldica.core.public.disco.port=
aldica.core.local.disco.port=47110
aldica.core.local.disco.portRange=0
# Ignite default is 0
aldica.core.local.disco.joinTimeout=0
# Ignite default is 5000
aldica.core.local.disco.ackTimeout=5000
# Ignite default is 5000
aldica.core.local.disco.socketTimeout=5000
# Ignite default is 5000, we grant more time to complete operations (e.g. join)
aldica.core.local.disco.networkTimeout=15000

aldica.core.local.disco.registrationRefresh.cron=0 0 2 * * ?

aldica.core.public.comm.port=
aldica.core.local.comm.port=47100
aldica.core.local.comm.portRange=0
# Ignite default is 0, set to 10000 to avoid OOME (and avoid one of the startup WARN messages)
aldica.core.local.comm.messageQueueLimit=10000
# defaults are 5000 and 600000 (quite significant)
# this can cause long join/startup/rebalance scenarios, especially in NATed / Dockerised / Kubernetes environments with unreachable, internal addresses
aldica.core.local.comm.connectTimeout=1000
aldica.core.local.comm.maxConnectTimeout=10000
# Ignite default is 2000
aldica.core.local.comm.socketWriteTimeout=2000
# Ignite default is 1
aldica.core.local.comm.connectionsPerNode=1
# Ignite default is false, might need to be changed in NATed / Dockerised / Kubernetes environment to avoid connection attempts to unreachable, internal addresses
aldica.core.local.comm.filterReachableAddresses=false

aldica.core.failureDetectionTimeout=10000
aldica.core.systemWorkerBlockedTimeout=10000

# default is actually Math.max(8, #available_proc_count)
aldica.core.publicThreadPoolSize=8
# default is actually Math.max(8, #available_proc_count)
aldica.core.stripedThreadPoolSize=8
# Ignite default is same as public thread pool size
aldica.core.serviceThreadPoolSize=8
# Ignite default is same as public thread pool size
aldica.core.systemThreadPoolSize=8
# Ignite default is same as public thread pool size
aldica.core.asyncCallbackThreadPoolSize=8
# Ignite default is 4
aldica.core.managementThreadPoolSize=4
# despite p2p being disabled we have to allow pool of 1 thread (default 2)
aldica.core.peerClassLoadingThreadPoolSize=1
# despite not using igfs we have to allow pool of 1 thread (default = #available_proc_count)
# aldica.core.igfsThreadPoolSize=1
# Ignite default is same as public thread pool size
aldica.core.dataStreamerThreadPoolSize=8
# Ignite default is same as public thread pool size
aldica.core.utilityCacheThreadPoolSize=8
# despite not using query we have to allow pool of 1 thread (default = public thread pool size)
aldica.core.queryThreadPoolSize=1
# Ignite default is 4 - must be lower than system thread pool size
aldica.core.rebalanceThreadPoolSize=4

# 8K page size, 20 - 40 MiB system storage, 1 - 16 GiB default storage
aldica.core.storage.pageSize=16384
aldica.core.storage.systemInitialSize=20971520
aldica.core.storage.systemMaxSize=41943040
aldica.core.storage.defaultStorageRegion.initialSize=1073741824
aldica.core.storage.defaultStorageRegion.maxSize=17179869184
aldica.core.storage.defaultStorageRegion.swapPath=\${java.io.tmpdir}/aldica/defaultDataRegionSwap

# Custom serialisations - global flags
aldica.core.binary.optimisation.enabled=true
aldica.core.binary.optimisation.useRawSerial=true
aldica.core.binary.optimisation.useIdsWhenReasonable=true
aldica.core.binary.optimisation.useIdsWhenPossible=true

# Custom serialisation - specific flags (some trivial/general optimisations should always be enabled regardless of global flag)
aldica.core.binary.optimisation.txnCacheKey.enabled=true
aldica.core.binary.optimisation.txnCacheKey.useRawSerial=true
aldica.core.binary.optimisation.cacheKey.enabled=true
aldica.core.binary.optimisation.cacheKey.useRawSerial=true
aldica.core.binary.optimisation.cacheValueKey.enabled=true
aldica.core.binary.optimisation.cacheValueKey.useRawSerial=true
aldica.core.binary.optimisation.storeRef.enabled=true
aldica.core.binary.optimisation.storeRef.useRawSerial=true
aldica.core.binary.optimisation.nodeRef.enabled=true
aldica.core.binary.optimisation.nodeRef.useRawSerial=true
aldica.core.binary.optimisation.qname.enabled=true
aldica.core.binary.optimisation.qname.useRawSerial=true
# enabled to avoid warnings about Externalizable although that is more efficient
aldica.core.binary.optimisation.moduleVersionNumber.enabled=true
aldica.core.binary.optimisation.moduleVersionNumber.useRawSerial=true
aldica.core.binary.optimisation.contentData.enabled=true
aldica.core.binary.optimisation.contentData.useRawSerial=true
aldica.core.binary.optimisation.contentData.useIdsWhenReasonable=true
aldica.core.binary.optimisation.mlText.enabled=true
aldica.core.binary.optimisation.mlText.useRawSerial=true
aldica.core.binary.optimisation.mlText.useIdsWhenReasonable=true
aldica.core.binary.optimisation.nodeAspects.enabled=true
aldica.core.binary.optimisation.nodeAspects.useRawSerial=true
aldica.core.binary.optimisation.nodeAspects.useIdsWhenReasonable=true
aldica.core.binary.optimisation.nodeProperties.enabled=true
aldica.core.binary.optimisation.nodeProperties.useRawSerial=true
aldica.core.binary.optimisation.nodeProperties.useIdsWhenReasonable=true
aldica.core.binary.optimisation.nodeProperties.useIdsWhenPossible=true

aldica.caches.enabled=true

aldica.caches.instance.name=repositoryGrid
aldica.caches.partitionsCount=32
aldica.caches.remoteSupport.enabled=false
aldica.caches.ignoreDefaultEvictionConfiguration=true
# Flag was introduced to deal with https://issues.apache.org/jira/browse/IGNITE-11352
# Since this has been dealt with, it only serves to globally disable statistics for potential performance impact
aldica.caches.disableAllStatistics=false

aldica.webSessionCache.enabled=false
aldica.webSessionCache.instanceName=repositoryGrid
aldica.webSessionCache.cacheName=servlet.webSessionCache
aldica.webSessionCache.retriesOnFailure=2
aldica.webSessionCache.retriesTimeout=5000
aldica.webSessionCache.keepBinary=true

aldica.webSessionCache.cacheMode=REPLICATED
aldica.webSessionCache.maxSize=10000

# Custom serialisations emitter config
aldica.core.binary.type.org.alfresco.repo.cache.TransactionalCache$CacheRegionKey.enabled=true
aldica.core.binary.type.org.alfresco.repo.cache.TransactionalCache$CacheRegionKey.serializer=Configuration.aldica.core.binary.serializer.alfresco.optimisedTxnCacheRegionKey
aldica.core.binary.type.org.alfresco.repo.cache.lookup.CacheRegionKey.enabled=true
aldica.core.binary.type.org.alfresco.repo.cache.lookup.CacheRegionKey.serializer=Configuration.aldica.core.binary.serializer.alfresco.optimisedCacheRegionKey
aldica.core.binary.type.org.alfresco.repo.cache.lookup.CacheRegionValueKey.enabled=true
aldica.core.binary.type.org.alfresco.repo.cache.lookup.CacheRegionValueKey.serializer=Configuration.aldica.core.binary.serializer.alfresco.optimisedCacheRegionValueKey
aldica.core.binary.type.org.alfresco.service.cmr.repository.StoreRef.enabled=true
aldica.core.binary.type.org.alfresco.service.cmr.repository.StoreRef.serializer=Configuration.aldica.core.binary.serializer.alfresco.optimisedStoreRef
aldica.core.binary.type.org.alfresco.service.cmr.repository.NodeRef.enabled=true
aldica.core.binary.type.org.alfresco.service.cmr.repository.NodeRef.serializer=Configuration.aldica.core.binary.serializer.alfresco.optimisedNodeRef
aldica.core.binary.type.org.alfresco.service.namespace.QName.enabled=true
aldica.core.binary.type.org.alfresco.service.namespace.QName.serializer=Configuration.aldica.core.binary.serializer.alfresco.optimisedQName
aldica.core.binary.type.org.alfresco.service.cmr.repository.MLText.enabled=true
aldica.core.binary.type.org.alfresco.service.cmr.repository.MLText.serializer=Configuration.aldica.core.binary.serializer.alfresco.optimisedMLText
aldica.core.binary.type.org.alfresco.repo.domain.node.ContentDataWithId.enabled=true
aldica.core.binary.type.org.alfresco.repo.domain.node.ContentDataWithId.serializer=Configuration.aldica.core.binary.serializer.alfresco.optimisedContentData
aldica.core.binary.type.org.alfresco.service.cmr.repository.ContentData.enabled=true
aldica.core.binary.type.org.alfresco.service.cmr.repository.ContentData.serializer=Configuration.aldica.core.binary.serializer.alfresco.optimisedContentData
aldica.core.binary.type.org.alfresco.repo.module.ModuleVersionNumber.enabled=true
aldica.core.binary.type.org.alfresco.repo.module.ModuleVersionNumber.serializer=Configuration.aldica.core.binary.serializer.alfresco.optimisedModuleVersionNumber

aldica.core.binary.type.org.aldica.cache.NodeAspectsCacheSet.enabled=true
aldica.core.binary.type.org.aldica.cache.NodeAspectsCacheSet.serializer=Configuration.aldica.core.binary.serializer.alfresco.optimisedNodeAspects
aldica.core.binary.type.org.aldica.cache.NodePropertiesCacheMap.enabled=true
aldica.core.binary.type.org.aldica.cache.NodePropertiesCacheMap.serializer=Configuration.aldica.core.binary.serializer.alfresco.optimisedNodeProperties

aldica.caches.node.aspectsCache._process=true
aldica.caches.node.aspectsCache._className=org.aldica.repo.ignite.cache.ValueTransformingTransactionalCache
aldica.caches.node.aspectsCache.property.valueTransformer.ref=aldica-nodeAspectsCacheValueTransformer

aldica.caches.node.propertiesCache._process=true
aldica.caches.node.propertiesCache._className=org.aldica.repo.ignite.cache.ValueTransformingTransactionalCache
aldica.caches.node.propertiesCache.property.valueTransformer.ref=aldica-nodePropertiesCacheValueTransformer


# Cache emitter config
# this configures "our" cache and lock store factories
aldica.caches.cacheFactory._className=org.aldica.repo.ignite.cache.CacheFactoryImpl
# for some reason no bean forces Log4j hierarchy to be initialised sooner - so we do
aldica.caches.cacheFactory._dependsOn=log4JHierarchyInit
aldica.caches.cacheFactory.property.instanceName=repositoryGrid
aldica.caches.cacheFactory.property.partitionsCount=32
aldica.caches.cacheFactory.property.enableRemoteSupport=false
aldica.caches.cacheFactory.property.ignoreDefaultEvictionConfiguration=true
aldica.caches.cacheFactory.property.disableAllStatistics=false

aldica.caches.lockStoreFactory._className=org.aldica.repo.ignite.lock.LockStoreFactoryImpl
aldica.caches.lockStoreFactory.property.instanceName=repositoryGrid
aldica.caches.lockStoreFactory.property.partitionsCount=32
aldica.caches.lockStoreFactory.property.enableRemoteSupport=false
aldica.caches.lockStoreFactory.property.disableAllStatistics=false

# Alfresco cache configs
# Custom cache configurations to work with special service initialisation caches
cache.immutableSingletonSharedCache.ignite.cache.type=invalidatingDefaultSimple
cache.globalConfigSharedCache.ignite.cache.type=invalidatingDefaultSimple
cache.routingContentStoreSharedCache.ignite.cache.type=localDefaultSimple
cache.cachingContentStoreCache.ignite.cache.type=localDefaultSimple


# needs by-reference semantics due to "locked" state (IMHO a design bug which prevents full distribution + perfect synchronicity)
# also can't disable forceInvalidateOnPut as cache interaction design for this cache is bad (TTL, update put without prior read put to be able to detect actual change)
# this cache will cause significant increase in pointless re-read SQL queries in a grid when requests for same node are routed to different grid node every time
# TODO May need an even more special cache implementation for this one to fix Alfresco's issues
cache.node.nodesSharedCache.ignite.cache.type=invalidatingDefaultSimple

# tickets need to be fully replicated to avoid system locking up during joins
# cache usage pattern with getKeys() (not so smart an approach) would call out to other servers on ticket / auth check on each request otherwise
cache.ticketsCache.ignite.cache.type=replicated

# may have a few hundred to low thousands of entries
# these values are critical for almost any operation so they should always be fully replicated
cache.immutableEntitySharedCache.ignite.cache.type=replicated
# setup on-heap cache layer to optimise access
cache.immutableEntitySharedCache.ignite.heap.maxItems=5000
cache.immutableEntitySharedCache.ignite.heap.eviction-policy=${cache.immutableEntitySharedCache.eviction-policy}
# avoid stupendous amount of overhead + ping-pong invalidation/reload if set to invalidating
cache.immutableEntitySharedCache.ignite.forceInvalidateOnPut=false
cache.immutableEntitySharedCache.ignite.allowValueSentinels=false

# Some optimisations of cache configurations (smaller footprint due to usage patterns not requiring full Ignite caches)
# Will usually only have less than a handful of entries - a bit more if multi-tenancy is used
cache.node.rootNodesSharedCache.ignite.cache.type=invalidatingDefaultSimple
cache.node.rootNodesSharedCache.ignite.forceInvalidateOnPut=false
cache.node.rootNodesSharedCache.ignite.allowValueSentinels=false
cache.node.allRootNodesSharedCache.ignite.cache.type=invalidatingDefaultSimple
cache.node.allRootNodesSharedCache.ignite.forceInvalidateOnPut=false
cache.node.allRootNodesSharedCache.ignite.allowValueSentinels=false

# partition all the significantly large / growing caches (if not already fully-distributed in default Alfresco config)
cache.node.aspectsSharedCache.ignite.cache.type=partitioned
cache.node.propertiesSharedCache.ignite.cache.type=partitioned
cache.propertyValueCache.ignite.cache.type=partitioned
cache.propertyUniqueContextSharedCache.ignite.cache.type=partitioned

# will usually only have as many entries as tenants (typically just one)
# also, forceInvalidation (Alfresco default behaviour) might cause ping-pong invalidation/reload
# lastly, messages / resource bundles may be server-specific due to inclusion of resources from the local classpath, so should not be shared with servers in grid
cache.messagesSharedCache.ignite.cache.type=invalidatingDefaultSimple
cache.messagesSharedCache.ignite.forceInvalidateOnPut=false
cache.loadedResourceBundlesSharedCache.ignite.cache.type=invalidatingDefaultSimple
cache.loadedResourceBundlesSharedCache.ignite.forceInvalidateOnPut=false
cache.resourceBundleBaseNamesSharedCache.ignite.cache.type=invalidatingDefaultSimple
cache.resourceBundleBaseNamesSharedCache.ignite.forceInvalidateOnPut=false

# will usually have maybe a dozen to a few dozen entries
cache.propertyClassCache.ignite.cache.type=invalidatingDefaultSimple
cache.propertyClassCache.ignite.forceInvalidateOnPut=false
cache.propertyClassCache.ignite.allowValueSentinels=false

# just lookup caches - not essential enough for partitioning / replication
cache.node.childByNameSharedCache.ignite.cache.type=localDefaultSimple
cache.authoritySharedCache.ignite.cache.type=invalidatingDefaultSimple
cache.authoritySharedCache.ignite.forceInvalidateOnPut=false
cache.authoritySharedCache.ignite.allowValueSentinels=false
cache.authorityToChildAuthoritySharedCache.ignite.cache.type=invalidatingDefaultSimple
cache.authorityToChildAuthoritySharedCache.ignite.forceInvalidateOnPut=false
cache.authorityToChildAuthoritySharedCache.ignite.allowValueSentinels=false
cache.zoneToAuthoritySharedCache.ignite.cache.type=invalidatingDefaultSimple
cache.zoneToAuthoritySharedCache.ignite.forceInvalidateOnPut=false
cache.zoneToAuthoritySharedCache.ignite.allowValueSentinels=false

# As far as is known this is obsolete since 5.x
cache.webServicesQuerySessionSharedCache.ignite.cache.type=localDefaultSimple
# New cache in 5.2
cache.openCMISRegistrySharedCache.ignite.cache.type=invalidatingDefaultSimple


# compatibility with OOTBee Support Tools
ootbee-support-tools.cache.org.aldica.repo.ignite.cache.SimpleIgniteBackedCache.clearable=true
ootbee-support-tools.cache.org.aldica.repo.ignite.cache.InvalidatingCacheFacade.clearable=true